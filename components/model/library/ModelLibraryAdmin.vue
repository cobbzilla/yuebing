<!-- DO NOT EDIT THIS FILE. AUTO-GENERATED BY mobiletto-orm-typedef-gen -->

<template>
  <v-container>
    <v-row v-if="successSnackbar && successSnackbar.length > 0">
      <KitSnackbarSuccess :text="successSnackbar" />
    </v-row>
    <v-row v-else-if="errorSnackbar && errorSnackbar.length > 0">
      <KitSnackbarError :text="errorSnackbar" />
    </v-row>
    <v-row>
      <v-col>
        <h2>{{ adminTitle() }}</h2>
        <b v-if="messageExists('title_library_admin_details', messages)">
          {{ messages.title_library_admin_details }}
        </b>
      </v-col>
    </v-row>
    <div>
      <v-row v-if="addingObject">
        <v-col>
          <OrmForm
            v-if="allRefsLoaded() && libraryTypeDef"
            form-name="add_library_form"
            :type-def="libraryTypeDef"
            :type-name-message="typeNameMessage"
            :thing="addObject"
            :fields="libraryTypeDefFields"
            :create="true"
            :read-only-object="() => false"
            :server-errors="createLibraryServerErrors"
            :label-prefixes="labelPfx"
            :hint-suffixes="['_description']"
            @submitted="onAddSubmitted"
            @update="onAddUpdated"
            @cancel="onAddCancel"
          />
        </v-col>
      </v-row>
      <v-row v-else-if="Object.keys(editingObject).length > 0">
        <v-col>
          <OrmForm
            v-if="allRefsLoaded() && libraryTypeDef"
            form-name="edit_library_form"
            :type-def="libraryTypeDef"
            type-name-message="typeNameMessage"
            :thing="editingObject"
            :fields="libraryTypeDefFields"
            :create="false"
            :read-only-object="() => false"
            :server-errors="editLibraryServerErrors"
            :label-prefixes="labelPfx"
            :hint-suffixes="['_description']"
            @submitted="onEditSubmitted"
            @update="onEditUpdated"
            @cancel="onEditCancel"
          />
        </v-col>
      </v-row>
      <v-row v-else-if="allRefsLoaded() && libraryTypeDef">
        <v-col>
          <v-container>
            <v-row v-if="(libraryList && libraryList.length > 0) || searched">
              <v-col>
                <div>
                  <v-form @submit.prevent="searchObjects">
                    <div class="form-group">
                      <v-text-field
                        v-model="searchTerms"
                        :label="messages.label_search"
                        :disabled="libraryStore.libraryBusy"
                        type="text"
                        name="searchTerms"
                        class="form-control"
                        @keyup.enter="searchObjects"
                      />
                      <v-btn class="btn btn-primary" :disabled="libraryStore.libraryBusy" @click.stop="searchObjects">
                        <Icon name="material-symbols:search" />
                      </v-btn>
                    </div>
                  </v-form>
                </div>
              </v-col>
            </v-row>
            <v-row>
              <v-col>
                <table v-if="libraryList && libraryList.length > 0">
                  <thead>
                  <tr>
                    <th v-for="(tableField, tableFieldIndex) in tableFields" :key="tableFieldIndex">
                      {{ tableFieldMessages[tableField] }}
                    </th>
                    <th v-if="Object.keys(actionConfigs).length > 0">
                      <Icon name="material-symbols:target" />
                    </th>
                    <th></th>
                    <th></th>
                  </tr>
                  </thead>
                  <tbody>
                  <tr v-for="(obj, objIndex) in libraryList" :key="objIndex">
                    <td v-for="(fieldName, fieldIndex) in tableFields" :key="fieldIndex">
                      <OrmFieldDisplay v-if="libraryTypeDef.fields[fieldName] || fieldName.startsWith('_meta')" :field="fieldName.startsWith('_meta') ? metaField(fieldName) : libraryTypeDef.fields[fieldName]" :value="deepGet(obj, fieldName)" />
                    </td>
                    <td v-if="Object.keys(actionConfigs).length > 0">
                      <div v-for="(action, actionIndex) in Object.keys(actionConfigs)" :key="actionIndex">
                        <NuxtLink
                          v-if="actionEnabled(obj, action)"
                          :to="{ path: `${actionConfig(action).path}/${deepGet(obj, libraryTypeDef.idField(obj) as string)}` }"
                        >
                          <v-btn>
                            {{ messages[actionConfig(action).message] }}
                          </v-btn>
                        </NuxtLink>
                      </div>
                    </td>
                    <td>
                      <v-btn v-if="canEdit(obj, libraryList)" :disabled="libraryStore.libraryBusy" @click.stop="showEditOrm(obj)">
                        <Icon name="material-symbols:edit" />
                      </v-btn>
                    </td>
                    <td>
                      <v-btn v-if="canDelete(obj, libraryList)" :disabled="libraryStore.libraryBusy" @click.stop="delObject(obj)">
                        <Icon name="material-symbols:delete" />
                      </v-btn>
                    </td>
                  </tr>
                  </tbody>
                </table>
              </v-col>
            </v-row>
            <v-row>
              <v-col>
                <v-btn class="btn btn-primary" :disabled="libraryStore.libraryBusy" @click.stop="showAddOrm">
                  <Icon name="material-symbols:add" />
                </v-btn>
              </v-col>
            </v-row>
          </v-container>
        </v-col>
      </v-row>
      <v-row v-else>
        <v-col>
          <Icon name="material-symbols:clock-outline" />
        </v-col>
      </v-row>
    </div>
  </v-container>
</template>

<script setup lang="ts">
  import { ref, watch, Ref } from "vue";
  import { storeToRefs } from "pinia";
  import {
    MobilettoOrmFieldDefConfig,
    MobilettoOrmObject,
    MobilettoOrmTypeDef,
    MobilettoOrmValidationErrors,
    metaField
  } from "mobiletto-orm-typedef";
  import { LibraryType, LibraryTypeDef } from "yuebing-model";
  import { findMessage, messageExists, parseMessage, normalizeMsg } from "hokey-runtime";
  import { useSessionStore } from "~/stores/sessionStore";
  import { useLibraryStore } from "~/stores/model/libraryStore";
  import { useMediaStore } from "~/stores/model/mediaStore";
  import { useSourceStore } from "~/stores/model/sourceStore";
  import { useDestinationStore } from "~/stores/model/destinationStore";
  import { deepUpdate } from "~/utils/model/adminHelper";
  const successSnackbar = ref("");
  const errorSnackbar = ref("");
  type ActionConfig = {
    path: string;
    message: string;
    when: (obj: MobilettoOrmObject) => boolean;
  };
  const props = withDefaults(
    defineProps<{
      labelPrefixes: string[];
      typeNameMessage: string;
      msgAddSuccess: string;
      msgAddError: string;
      msgEditSuccess: string;
      msgEditError: string;
      msgDeleteSuccess: string;
      msgDeleteError: string;
      actionConfigs: Record<string, ActionConfig>;
      canAdd: (obj: MobilettoOrmObject, objList: MobilettoOrmObject[]) => boolean;
      canEdit: (obj: MobilettoOrmObject, objList: MobilettoOrmObject[]) => boolean;
      canDelete: (obj: MobilettoOrmObject, objList: MobilettoOrmObject[]) => boolean;
      deleteConfirmationMessage: string;
      maxDeleteConfirmations: number;
    }>(),{
      labelPrefixes: () => ["label_", ""],
      typeNameMessage: () => "typename_library",
      msgAddSuccess: () => "admin_info_added",
      msgAddError: () => "admin_info_add_error",
      msgEditSuccess: () => "admin_info_edited",
      msgEditError: () => "admin_info_edit_error",
      msgDeleteSuccess: () => "admin_info_deleted",
      msgDeleteError: () => "admin_info_delete_error",
      actionConfigs: () => ({}),
      canAdd: () => true,
      canEdit: () => true,
      canDelete: () => true,
      maxDeleteConfirmations: () => 3,
    },
  );

  const emit = defineEmits<{
    added: [obj: LibraryType];
    addCanceled: [];
    edited: [obj: LibraryType];
    editCanceled: [obj: LibraryType];
    deleted: [obj: LibraryType];
  }>();

  const labelPfx: Ref<string[]> = ref(["admin_label_library_", "label_", ""]);
  if (props.labelPrefixes) {
    props.labelPrefixes.forEach((p: string) => {
      if (!labelPfx.value.includes(p)) labelPfx.value.unshift(p);
    });
  }

  const sessionStore = useSessionStore();
  const { localeMessages } = storeToRefs(sessionStore);
  const messages = localeMessages;

  const adminTitle = () => messageExists("admin_title_library_administration", messages.value)
    ? messages.value.admin_title_library_administration
    : parseMessage("admin_title_site_administration", messages.value, { title: findMessage(props.typeNameMessage, messages.value, [""])});

  const addingObject = ref(false);
  const addObject = ref({} as LibraryType);
  const createLibraryServerErrors = ref({} as MobilettoOrmValidationErrors);

  const editingObject = ref({} as LibraryType);
  const editLibraryServerErrors = ref({} as MobilettoOrmValidationErrors);
  const deleteLibraryServerErrors = ref({} as MobilettoOrmValidationErrors);

  const pageNumber = ref(1);
  const pageSize = ref(20);
  const searchTerms = ref("");
  const searched = ref(false);
  const lastQuery = ref({});

  const tableFields: Ref<string[]> = ref([]);

  const tableFieldMessages: Ref<Record<string, string>> = ref({});
  const initTableFieldMessages = (tableFields: string[]) => {
      const defaultTableFieldMessages: Record<string, string> = {};
      tableFields.forEach((f: string) => {
        defaultTableFieldMessages[f] = findMessage(normalizeMsg(f), messages.value, props.labelPrefixes);
      });
      tableFieldMessages.value = defaultTableFieldMessages;
  };

  const libraryStore = useLibraryStore();
  const { libraryList  } = storeToRefs(libraryStore);
  const libraryTypeDef: Ref<MobilettoOrmTypeDef | null> = ref(null);
  const libraryTypeDefFields: Ref<MobilettoOrmFieldDefConfig[] | undefined> = ref(undefined);
  const searchQuery = () => ({ textSearch: searchTerms.value });

  const searchObjects = () => {
    const query = searchQuery();
    if (lastQuery.value && JSON.stringify(lastQuery.value) === JSON.stringify(query)) {
      // not sending duplicate search
    } else {
      searched.value = true;
      lastQuery.value = Object.assign({}, query);
      libraryStore.search(query);
    }
  };

  const navigating = ref(false);
  const initTypeDef = () => {
    const typeDef = LibraryTypeDef.extend({
      fields: {
      
        media: { ...refMedia.value },
      
        sources: { ...refSource.value },
      
        destinations: { ...refDestination.value },
      
      }
    });
    libraryTypeDefFields.value = typeDef.tabIndexedFields();
    libraryTypeDef.value = typeDef;
    tableFields.value = libraryTypeDef.value.tableFields && Array.isArray(libraryTypeDef.value.tableFields)
      ? libraryTypeDef.value.tableFields
      : libraryTypeDef.value.primary
        ? [libraryTypeDef.value.primary, "ctime", "mtime"]
        : ["id", "ctime", "mtime"];
    initTableFieldMessages(tableFields.value);
  }

  const allRefs: Ref<Boolean>[] = [];
  const allRefsLoaded = () => allRefs.length === 3 && allRefs.filter(r => r.value === true).length === 3;

  const refMedia = ref({} as MobilettoOrmFieldDefConfig);
  const refMediaLoaded = ref(false);
  allRefs.push(refMediaLoaded);
  const mediaStore = useMediaStore();
  const { mediaList } = storeToRefs(mediaStore);

  watch(mediaList, (newList) => {
    if (newList && newList.length === 0) {
      if (navigating.value) return;
      navigating.value = true;
      navigateTo("/admin/media/setup");
    } else if (newList && newList.length > 0) {
      refMedia.value.values = newList.map((s) => s.name);
      refMedia.value.labels = newList.map((s) => s.name);
      refMedia.value.items = newList.map((s) => ({
        label: s.name,
        value: s.name,
        title: s.name,
        rawLabel: true,
      }));
      addObject.value.media = refMedia.value.values as any;
      refMediaLoaded.value = true;
      if (allRefsLoaded()) {
        initTypeDef()
      }
    }
  });const refSource = ref({} as MobilettoOrmFieldDefConfig);
  const refSourceLoaded = ref(false);
  allRefs.push(refSourceLoaded);
  const sourceStore = useSourceStore();
  const { sourceList } = storeToRefs(sourceStore);

  watch(sourceList, (newList) => {
    if (newList && newList.length === 0) {
      if (navigating.value) return;
      navigating.value = true;
      navigateTo("/admin/source/setup");
    } else if (newList && newList.length > 0) {
      refSource.value.values = newList.map((s) => s.name);
      refSource.value.labels = newList.map((s) => s.name);
      refSource.value.items = newList.map((s) => ({
        label: s.name,
        value: s.name,
        title: s.name,
        rawLabel: true,
      }));
      addObject.value.sources = refSource.value.values as any;
      refSourceLoaded.value = true;
      if (allRefsLoaded()) {
        initTypeDef()
      }
    }
  });const refDestination = ref({} as MobilettoOrmFieldDefConfig);
  const refDestinationLoaded = ref(false);
  allRefs.push(refDestinationLoaded);
  const destinationStore = useDestinationStore();
  const { destinationList } = storeToRefs(destinationStore);

  watch(destinationList, (newList) => {
    if (newList && newList.length === 0) {
      if (navigating.value) return;
      navigating.value = true;
      navigateTo("/admin/destination/setup");
    } else if (newList && newList.length > 0) {
      refDestination.value.values = newList.map((s) => s.name);
      refDestination.value.labels = newList.map((s) => s.name);
      refDestination.value.items = newList.map((s) => ({
        label: s.name,
        value: s.name,
        title: s.name,
        rawLabel: true,
      }));
      addObject.value.destinations = refDestination.value.values as any;
      refDestinationLoaded.value = true;
      if (allRefsLoaded()) {
        initTypeDef()
      }
    }
  });
  const onAddUpdated = (update: { field: string; value: any }) => {
    deepUpdate(addObject.value, update.field, update.value);
  };
  const onAddSubmitted = async (obj: MobilettoOrmObject) => {
    await libraryStore
      .create(obj as LibraryType, createLibraryServerErrors);
    addingObject.value = false;
    successSnackbar.value = parseMessage(props.msgAddSuccess, messages.value, {
        type: messages.value.typename_library,
        id: LibraryTypeDef.id(obj),
    });
    emit("added", obj);
    addObject.value = {} as LibraryType;
    return await libraryStore.search();
  }
  watch(createLibraryServerErrors, () => {
    if (createLibraryServerErrors.value && Object.keys(createLibraryServerErrors.value).length > 0) {
      errorSnackbar.value = parseMessage(props.msgAddError, messages.value, {
        type: messages.value.typename_library,
        error: JSON.stringify(createLibraryServerErrors),
      });
    }
  });

  const showAddOrm = () => {
    addingObject.value = true;
  };
  const onAddCancel = () => {
    addingObject.value = false;
    emit("addCanceled");
  };

  const onEditUpdated = (update: { field: string; value: any }) => {
    if (editingObject.value) {
      deepUpdate(editingObject.value, update.field, update.value);
    }
  };

  const onEditSubmitted = async (obj: MobilettoOrmObject) => {
    await libraryStore
      .update(obj as LibraryType, editLibraryServerErrors);
    editingObject.value = {} as LibraryType;
    successSnackbar.value = parseMessage(props.msgEditSuccess, messages.value, {
      type: messages.value.typename_library,
      id: LibraryTypeDef.id(obj),
    });
    emit("edited", obj);
    return await libraryStore.search();
  };
  watch(editLibraryServerErrors, () => {
    if (editLibraryServerErrors.value && Object.keys(editLibraryServerErrors.value).length > 0) {
      errorSnackbar.value = parseMessage(props.msgEditError, messages.value, {
        type: messages.value.typename_library,
        id: LibraryTypeDef.id(editingObject.value),
        error: JSON.stringify(editLibraryServerErrors),
      });
    }
  });

  const showEditOrm = (obj: MobilettoOrmObject) => {
    if (Object.keys(editingObject.value).length > 0) {
      // already editing something else
      return;
    }
    if (obj) {
      const id = LibraryTypeDef.id(obj);
      if (id && id.length > 0) {
        addingObject.value = false; // ensure add form is closed
        editingObject.value = JSON.parse(JSON.stringify(obj)) as LibraryType;
      }
    }
  };
  const onEditCancel = () => {
    emit("editCanceled", editingObject.value);
    editingObject.value = {} as LibraryType;
  };

  const actionConfig = (action: string) => {
    return props.actionConfigs[action];
  };

  const actionEnabled = (obj: MobilettoOrmObject, action: string) => {
    const cfg = props.actionConfigs[action];
    if (!cfg.when || typeof cfg.when !== "function") {
      return true;
    }
    if (typeof cfg.when === "function") {
      return cfg.when(obj) === true;
    }
    return true;
  };
  const delConfirmCount = ref(0);
  const deletingObject = ref(null);
  const delObject = (obj: MobilettoOrmObject) => {
      if (props.deleteConfirmationMessage && props.deleteConfirmationMessage.length > 0 && delConfirmCount.value < maxDeleteConfirmations) {
          if (confirm(props.deleteConfirmationMessage)) {
              delConfirmCount.value = delConfirmCount.value + 1;
          } else {
              delConfirmCount.value = 0;
              return;
          }
      }
      deletingObject.value = obj;
      const id = LibraryTypeDef.id(obj);
      libraryStore.delete(id, deleteLibraryServerErrors)
          .then(() => {
              successSnackbar.value = parseMessage(props.msgDeleteSuccess, messages.value, {
                  type: messages.value.typename_library,
                  id: LibraryTypeDef.id(obj),
              });
              emit("deleted", obj);
              return libraryStore.search();
          });
  };
  watch(deleteLibraryServerErrors, () => {
    if (deleteLibraryServerErrors.value && Object.keys(deleteLibraryServerErrors.value).length > 0) {
        errorSnackbar.value = parseMessage(props.msgDeleteError, messages.value, {
            type: messages.value.typename_library,
            id: deletingObject.value ? LibraryTypeDef.id(deletingObject.value) : "null",
            error: JSON.stringify(deleteLibraryServerErrors),
        });
    }
  });
  watch(libraryList, (newList) => {
    if (newList && Array.isArray(newList) && newList.length === 0 && searchTerms.value && searchTerms.value.length === 0) {
      if (navigating.value) return;
      navigating.value = true;
      navigateTo("/admin/library/setup");
    }
  });

  const initRefs = async () => {
    const refSearches: Promise<[]>[] = [];
    refSearches.push(mediaStore.search());
    refSearches.push(sourceStore.search());
    refSearches.push(destinationStore.search());
    await Promise.all(refSearches);
    
  };
  libraryStore.search().then(() => {
    initRefs();
  });
</script>
