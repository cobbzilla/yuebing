#!/bin/sh

PROCESSOR_COUNT=$(grep -c ^processor /proc/cpuinfo)
DEFAULT_LOAD_MULTIPLE=6
DEFAULT_MAX_LOAD=$(expr ${PROCESSOR_COUNT} '*' ${DEFAULT_LOAD_MULTIPLE})

YB_MAX_XFORM_LOAD=${YB_MAX_XFORM_LOAD:-${DEFAULT_MAX_LOAD}}
YB_LOAD_LOG="${YB_WORK_DIR:-'/tmp'}/ffmpeg_load.log"

SCRIPT="${0}"

log () {
  echo "${SCRIPT} [$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "${YB_LOAD_LOG}"
}

# This block of load-related code is to keep the system from grinding
# to a halt.

# Sometimes queue management is hard and we spin up too many ffmpeg jobs
# Before the system dies, let's stall jobs here, wait for the system
# load to go below a threshold

LOAD="$(awk '{print $1}' /proc/loadavg | awk -F '.' '{print $1}')"
if [ -z "${LOAD}" ] ; then
  log "Unable to determine load, running: ffmpeg $*"
elif [ ${LOAD} -gt ${YB_MAX_LOAD} ] ; then
  while [ ${LOAD} -gt ${YB_MAX_LOAD} ] ; do
    log "Load is too high (${LOAD} > ${YB_MAX_LOAD}), waiting to start: ffmpeg $*"
    sleep 10
    LOAD="$(awk '{print $1}' /proc/loadavg | awk -F '.' '{print $1}')"
    if [ -z "${LOAD}" ] ; then
      log "Unable to determine load, running ffmpeg $*"
      break
    fi
  done
else
  log "Load is OK (${LOAD} <= ${YB_MAX_LOAD}) we can run ffmpeg $*"
fi

log "RUNNING: ffmpeg $*"

exec ffmpeg "$@"
